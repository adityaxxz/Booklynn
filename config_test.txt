#Commented out: URL normalization and SQLite handling

@field_validator("DATABASE_URL", mode="after")
@classmethod
def ensure_async_database_url(cls, database_url: str) -> str:
    if not database_url:
        return database_url
    # Handle accidental prefix like "DATABASE_URL=..."
    if database_url.startswith("DATABASE_URL="):
        database_url = database_url.split("=", 1)[1]
    # Normalize postgres schemes
    if database_url.startswith("postgresql+psycopg2://"):
        return database_url.replace("postgresql+psycopg2://", "postgresql+asyncpg://", 1)
    if database_url.startswith("postgresql://"):
        return database_url.replace("postgresql://", "postgresql+asyncpg://", 1)
    if database_url.startswith("postgres://"):
        return database_url.replace("postgres://", "postgresql+asyncpg://", 1)
    # Normalize sqlite sync to async
    if database_url.startswith("sqlite:///") and not database_url.startswith("sqlite+aiosqlite:///"):
        return database_url.replace("sqlite:///", "sqlite+aiosqlite:///", 1)
    # Ensure SSL for Supabase (both direct and pooler) when using asyncpg
    if database_url.startswith("postgresql+asyncpg://") and (".supabase.co" in database_url or ".supabase.com" in database_url):
        parts = urlsplit(database_url)
        query_pairs = dict(parse_qsl(parts.query, keep_blank_values=True))
        if "ssl" not in query_pairs and "sslmode" not in query_pairs:
            query_pairs["ssl"] = "require"
            new_query = urlencode(query_pairs)
            database_url = urlunsplit((parts.scheme, parts.netloc, parts.path, new_query, parts.fragment))
    return database_url